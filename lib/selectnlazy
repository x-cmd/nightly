
___x_cmd_ui_selectnlazy(){
    ___x_cmd_ui_selectnlazy_mainloop "$@"
}

___x_cmd_ui_selectnlazy_test_func_ls(){
    if [ "$#" -eq 0 ]; then
        ls .
        return
    fi

    local IFS="/"
    local p="$*"
    [ ! -d "$p" ] && return 1

    ls "$p"
    return 0
}

___x_cmd_ui_selectnlazy_mainloop(){
    local func="$1"; shift
    ___x_cmd_ui_region_run ___x_cmd_ui_selectnlazy_mainloop_recursive_first
}

___x_cmd_ui_selectnlazy_mainloop_recursive_cur(){
    printf "%s" "$curlist" | awk -v idx="$curidx" 'NR==idx{ print $0; exit(0) }'
}

___x_cmd_ui_selectnlazy_mainloop_recursive_len(){
    printf "%s" "$curlist" | awk 'END{ print NR; }'
}

___x_cmd_ui_selectnlazy_mainloop_recursive_first(){
    local nextlist
    {
        ___x_cmd_ui_selectnlazy_mainloop_recursive_update_nextlist .
        ___x_cmd_ui_selectnlazy_mainloop_recursive 1
    } | awk './selectnlazy.awk'
}

___x_cmd_ui_send_newlist(){
    printf "%s %d" "---" "$1" "$2"
    shift 2
    printf "%s\n" "$*"
    printf "%s\n" "---"
}

___x_cmd_ui_send_data(){
    printf "%s\n" "$*"
}

___x_cmd_ui_selectnlazy_mainloop_recursive_sendview(){
    printf "R:%s:%s:%s%s" "$ticks" "$COLUMNS" "$LINES" "$___X_CMD_UI_REGION_RS" # send view
}

___x_cmd_ui_selectnlazy_mainloop_recursive_update_nextlist(){
    nextlist="$("$func" "$@")"
    expandable=$?

    if [ "$expandable" = 0 ]; then
        ___x_cmd_ui_send_newlist "$((curlevel+1))" 0 "$nextlist"
    else
        ___x_cmd_ui_send_newlist "$((curlevel+1))" -1
    fi
    ___x_cmd_ui_selectnlazy_mainloop_recursive_sendview
}

# Using calling stack to simulate list to avoid lacking of efficient array support in Posix Sh. Proudly implemented by me
___x_cmd_ui_selectnlazy_mainloop_recursive()(
    curlevel="${1:?Provide level}";             shift 1
    curlist="${nextlist}"
    curlistl="$(___x_cmd_ui_selectnlazy_mainloop_recursive_len)"
    curidx=1
    cur="$(___x_cmd_ui_selectnlazy_mainloop_recursive_cur)"

    ___x_cmd_ui_selectnlazy_mainloop_recursive_update_nextlist "$@" "$cur"

    while ___x_cmd_ui_getchar; do
        case "${___X_CMD_UI_GETCHAR_CHAR}" in
            UP)
                ___x_cmd_ui_varctl_num curidx 1 "$curlistl" dec
                cur="$(___x_cmd_ui_selectnlazy_mainloop_recursive_cur)"
                ___x_cmd_ui_send_data "C:$___X_CMD_UI_GETCHAR_TYPE:$___X_CMD_UI_GETCHAR_CHAR"
                ___x_cmd_ui_selectnlazy_mainloop_recursive_update_nextlist "$@" "$cur"
                ;;
            DN)
                ___x_cmd_ui_varctl_num curidx 1 "$curlistl" inc
                cur="$(___x_cmd_ui_selectnlazy_mainloop_recursive_cur)"
                ___x_cmd_ui_send_data "C:$___X_CMD_UI_GETCHAR_TYPE:$___X_CMD_UI_GETCHAR_CHAR"
                ___x_cmd_ui_selectnlazy_mainloop_recursive_update_nextlist "$@" "$cur"
                ;;
            LEFT)
                if [ "$curlevel" != 1 ]; then
                    ___x_cmd_ui_send_data "C:$___X_CMD_UI_GETCHAR_TYPE:$___X_CMD_UI_GETCHAR_CHAR"
                    ___x_cmd_ui_selectnlazy_mainloop_recursive_sendview
                    break
                fi
                ;;
            RIGHT)
                if [ "$expandable" = 0  ]; then
                    ___x_cmd_ui_send_data "C:$___X_CMD_UI_GETCHAR_TYPE:$___X_CMD_UI_GETCHAR_CHAR"
                    ___x_cmd_ui_selectnlazy_mainloop_recursive "$((curlevel+1))" "$@" "$cur"
                fi
                ;;
        esac
    done
)


