
# TODO: Multiple thread
# TODO: Download Manager and more strategy
# TODO: Maybe using a P2P share connection for mirror downloading.

___x_cmd_pkg_download(){
    local pkg_name="${1:?Provide pkg name}"
    local version="${2:?Provide version}"
    local osarch="${3:-${___X_CMD_PKG_OSARCH:-$(___x_cmd_pkg_osarch)}}"

    local url_list
    local file_suffix
    url_list="$(___x_cmd_pkg___list "$@" "$osarch" "url.${___X_CMD_WHICHNET:-_}" )"
    ___x_cmd_pkg___attr "$@" "$osarch" file_suffix

    local url
    local ball="$___X_CMD_PKG_DOWNLOAD_PATH/$pkg_name/$version.$file_suffix"
    mkdir -p "$___X_CMD_PKG_DOWNLOAD_PATH/$pkg_name"

    local sb_repo
    local sb_app
    ___x_cmd_pkg___static_build_attr "$@" "$osarch"
    if [ -n "$sb_repo" ] && [ -n "$sb_app" ]; then
        ___x_cmd_pkg_download_file___from_static_build_and_deflate "$sb_repo" "$sb_app"
        return
    fi
    pkg:debug "Download package url_list: $url_list ball: $ball"

    local md5
    local sha1
    local sha256
    local sha512

    ___x_cmd_pkg___attr "$@" "$osarch" "md5,sha1,sha256,sha512"

    if [ -f "$ball" ]; then
        ! ___x_cmd_pkg_download___check_hashsum "$ball" "$md5" "$sha1" "$sha256" "$sha512" || return 0

        pkg:warn "File corrupted. Download the $ball again."
        x rmrf "$ball"
    fi
    while read -r url; do
        # TODO: ___x_cmd_httpget support 302
        # ___x_cmd_httpget "$url" "$ball" || {
        pkg:info "Download package from $url to $ball"
        curl --progress-bar --location --retry-max-time 10 --retry 0 "$url" --output "$ball" || {
            pkg:warn "Fail to download from $url"
            continue
        }

        ! ___x_cmd_pkg_download___check_hashsum "$ball" "$md5" "$sha1" "$sha256" "$sha512" || return 0

        pkg:warn "File corrupted."
        x rmrf "$ball"
    done <<A
$url_list
A

}

___x_cmd_pkg_download_file___from_static_build_and_deflate(){
    local IFS='
    '
    local repo="${1:?Provide repo name, like p7zip}"
    local app="${2:-${repo}}"
    pkg:debug "Download from static-build. repo: $repo app: $app"

    local target="$HOME/.x-cmd/.bin/$app"
    mkdir -p "$target"

    local arch
    arch="$(os arch)"
    local osname
    osname="$(os name)"

    local exe
    case "$osname" in
        win)    exe=$repo.x64.exe        ;;
        *)      exe=$repo.${osname}.${arch}  ;;
    esac
    # Rely
    if [ ! -f "$target/$exe" ]; then

        pkg:info "Downloading: ${repo}/bin/$exe.7z"

        if ! ___x_cmd_curl_gitx static-build "${repo}" main "bin/$exe.7z" "$target/$exe.7z"; then
            pkg:warn "Download failure: $repo/main bin/$exe.7z"
            pkg:warn "File Not Found. Perhaps the platform is NOT supported: $exe"
            return 1
        fi

        (
            cd "$target" && {
                local size

                size=$(wc -c "$exe.7z")
                size=${size% *}
                size=$(printf "%s" $size)   # Notice: Intentionary let it unquoted.

                xrc p7zip
                if [ "$size" -gt 20 ]; then
                    p7zd x "$exe.7z" 1>/dev/null 2>/dev/null
                else
                    size="$(cat "$exe.7z")"
                    local i
                    local suffix

                    # TODO: using job for concurrency.
                    for i in $(seq "$size"); do
                        # suffix="$(printf "%03s" "$i")" # Not work in gnu bash
                        suffix="$(printf "%3s" "$i" | tr " " 0)"
                        if ! ___x_cmd_curl_gitx static-build "${repo}" main "bin/$exe.7z.$suffix" "$target/$exe.7z.$suffix"; then
                            pkg:warn "Download failure in $exe.7z.$suffix" >&2
                            return 1
                        fi
                    done

                    pkg:info "Using p7zd to decompress: $target/$exe.7z.001"
                    cat $target/$exe.7z.0* > $exe.7z
                    p7zd x "$exe.7z" 1>/dev/null 2>/dev/null
                fi && chmod +x "$exe" \
                    && pkg:info "Finish file decompress and chmod."
            }
        )
    fi && return 0
    return 1
}


___x_cmd_pkg_download___check_hashsum(){
    local filepath="$1"

    local md5="$2"
    local sha1="$3"
    local sha256="$4"
    local sha512="$5"

    if [ -n "$sha512" ]; then
        [ "$(___x_cmd_sha512 "$filepath")" != "$sha512" ]
    elif [ -n "$sha256" ]; then
        [ "$(___x_cmd_sha256 "$filepath")" != "$sha256" ]
    elif [ -n "$sha1" ]; then
        [ "$(___x_cmd_sha1 "$filepath")" != "$sha1" ]
    elif [ -n "$md5" ]; then
        [ "$(___x_cmd_md5 "$filepath")" != "$md5" ]
    else
        # In the future, will return 1
        x:warn "No checksum provided."
        return 0
    fi

}
